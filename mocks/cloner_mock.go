// Code generated by MockGen. DO NOT EDIT.
// Source: ../internal/pipelines/shared/cloner.go
//
// Generated by this command:
//
//	mockgen -source=../internal/pipelines/shared/cloner.go -destination=cloner_mock.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	dagger "dagger.io/dagger"
	shared "github.com/getsyntegrity/syntegrity-dagger/internal/pipelines/shared"
	gomock "go.uber.org/mock/gomock"
)

// MockCloner is a mock of Cloner interface.
type MockCloner struct {
	ctrl     *gomock.Controller
	recorder *MockClonerMockRecorder
	isgomock struct{}
}

// MockClonerMockRecorder is the mock recorder for MockCloner.
type MockClonerMockRecorder struct {
	mock *MockCloner
}

// NewMockCloner creates a new mock instance.
func NewMockCloner(ctrl *gomock.Controller) *MockCloner {
	mock := &MockCloner{ctrl: ctrl}
	mock.recorder = &MockClonerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCloner) EXPECT() *MockClonerMockRecorder {
	return m.recorder
}

// Clone mocks base method.
func (m *MockCloner) Clone(ctx context.Context, client *dagger.Client, opts shared.GitCloneOpts) (*dagger.Directory, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Clone", ctx, client, opts)
	ret0, _ := ret[0].(*dagger.Directory)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Clone indicates an expected call of Clone.
func (mr *MockClonerMockRecorder) Clone(ctx, client, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clone", reflect.TypeOf((*MockCloner)(nil).Clone), ctx, client, opts)
}

// MockRepoCloner is a mock of RepoCloner interface.
type MockRepoCloner struct {
	ctrl     *gomock.Controller
	recorder *MockRepoClonerMockRecorder
	isgomock struct{}
}

// MockRepoClonerMockRecorder is the mock recorder for MockRepoCloner.
type MockRepoClonerMockRecorder struct {
	mock *MockRepoCloner
}

// NewMockRepoCloner creates a new mock instance.
func NewMockRepoCloner(ctrl *gomock.Controller) *MockRepoCloner {
	mock := &MockRepoCloner{ctrl: ctrl}
	mock.recorder = &MockRepoClonerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepoCloner) EXPECT() *MockRepoClonerMockRecorder {
	return m.recorder
}

// Clone mocks base method.
func (m *MockRepoCloner) Clone(ctx context.Context, client *dagger.Client, opts shared.GitCloneOpts) (*dagger.Directory, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Clone", ctx, client, opts)
	ret0, _ := ret[0].(*dagger.Directory)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Clone indicates an expected call of Clone.
func (mr *MockRepoClonerMockRecorder) Clone(ctx, client, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clone", reflect.TypeOf((*MockRepoCloner)(nil).Clone), ctx, client, opts)
}
