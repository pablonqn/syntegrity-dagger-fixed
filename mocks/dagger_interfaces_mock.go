// Code generated by MockGen. DO NOT EDIT.
// Source: ../internal/pipelines/dagger_interfaces.go
//
// Generated by this command:
//
//	mockgen -source=../internal/pipelines/dagger_interfaces.go -destination=dagger_interfaces_mock.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	dagger "dagger.io/dagger"
	pipelines "github.com/getsyntegrity/syntegrity-dagger/internal/pipelines"
	gomock "go.uber.org/mock/gomock"
)

// MockDaggerClient is a mock of DaggerClient interface.
type MockDaggerClient struct {
	ctrl     *gomock.Controller
	recorder *MockDaggerClientMockRecorder
	isgomock struct{}
}

// MockDaggerClientMockRecorder is the mock recorder for MockDaggerClient.
type MockDaggerClientMockRecorder struct {
	mock *MockDaggerClient
}

// NewMockDaggerClient creates a new mock instance.
func NewMockDaggerClient(ctrl *gomock.Controller) *MockDaggerClient {
	mock := &MockDaggerClient{ctrl: ctrl}
	mock.recorder = &MockDaggerClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDaggerClient) EXPECT() *MockDaggerClientMockRecorder {
	return m.recorder
}

// CacheVolume mocks base method.
func (m *MockDaggerClient) CacheVolume(arg0 string) pipelines.DaggerCacheVolume {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheVolume", arg0)
	ret0, _ := ret[0].(pipelines.DaggerCacheVolume)
	return ret0
}

// CacheVolume indicates an expected call of CacheVolume.
func (mr *MockDaggerClientMockRecorder) CacheVolume(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheVolume", reflect.TypeOf((*MockDaggerClient)(nil).CacheVolume), arg0)
}

// Container mocks base method.
func (m *MockDaggerClient) Container() pipelines.DaggerContainer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Container")
	ret0, _ := ret[0].(pipelines.DaggerContainer)
	return ret0
}

// Container indicates an expected call of Container.
func (mr *MockDaggerClientMockRecorder) Container() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Container", reflect.TypeOf((*MockDaggerClient)(nil).Container))
}

// GetRealClient mocks base method.
func (m *MockDaggerClient) GetRealClient() *dagger.Client {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRealClient")
	ret0, _ := ret[0].(*dagger.Client)
	return ret0
}

// GetRealClient indicates an expected call of GetRealClient.
func (mr *MockDaggerClientMockRecorder) GetRealClient() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRealClient", reflect.TypeOf((*MockDaggerClient)(nil).GetRealClient))
}

// Host mocks base method.
func (m *MockDaggerClient) Host() pipelines.DaggerHost {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Host")
	ret0, _ := ret[0].(pipelines.DaggerHost)
	return ret0
}

// Host indicates an expected call of Host.
func (mr *MockDaggerClientMockRecorder) Host() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Host", reflect.TypeOf((*MockDaggerClient)(nil).Host))
}

// MockDaggerHost is a mock of DaggerHost interface.
type MockDaggerHost struct {
	ctrl     *gomock.Controller
	recorder *MockDaggerHostMockRecorder
	isgomock struct{}
}

// MockDaggerHostMockRecorder is the mock recorder for MockDaggerHost.
type MockDaggerHostMockRecorder struct {
	mock *MockDaggerHost
}

// NewMockDaggerHost creates a new mock instance.
func NewMockDaggerHost(ctrl *gomock.Controller) *MockDaggerHost {
	mock := &MockDaggerHost{ctrl: ctrl}
	mock.recorder = &MockDaggerHostMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDaggerHost) EXPECT() *MockDaggerHostMockRecorder {
	return m.recorder
}

// Directory mocks base method.
func (m *MockDaggerHost) Directory(arg0 string, arg1 pipelines.DaggerHostDirectoryOpts) pipelines.DaggerDirectory {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Directory", arg0, arg1)
	ret0, _ := ret[0].(pipelines.DaggerDirectory)
	return ret0
}

// Directory indicates an expected call of Directory.
func (mr *MockDaggerHostMockRecorder) Directory(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Directory", reflect.TypeOf((*MockDaggerHost)(nil).Directory), arg0, arg1)
}

// MockDaggerDirectory is a mock of DaggerDirectory interface.
type MockDaggerDirectory struct {
	ctrl     *gomock.Controller
	recorder *MockDaggerDirectoryMockRecorder
	isgomock struct{}
}

// MockDaggerDirectoryMockRecorder is the mock recorder for MockDaggerDirectory.
type MockDaggerDirectoryMockRecorder struct {
	mock *MockDaggerDirectory
}

// NewMockDaggerDirectory creates a new mock instance.
func NewMockDaggerDirectory(ctrl *gomock.Controller) *MockDaggerDirectory {
	mock := &MockDaggerDirectory{ctrl: ctrl}
	mock.recorder = &MockDaggerDirectoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDaggerDirectory) EXPECT() *MockDaggerDirectoryMockRecorder {
	return m.recorder
}

// GetRealDirectory mocks base method.
func (m *MockDaggerDirectory) GetRealDirectory() *dagger.Directory {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRealDirectory")
	ret0, _ := ret[0].(*dagger.Directory)
	return ret0
}

// GetRealDirectory indicates an expected call of GetRealDirectory.
func (mr *MockDaggerDirectoryMockRecorder) GetRealDirectory() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRealDirectory", reflect.TypeOf((*MockDaggerDirectory)(nil).GetRealDirectory))
}

// MockDaggerContainer is a mock of DaggerContainer interface.
type MockDaggerContainer struct {
	ctrl     *gomock.Controller
	recorder *MockDaggerContainerMockRecorder
	isgomock struct{}
}

// MockDaggerContainerMockRecorder is the mock recorder for MockDaggerContainer.
type MockDaggerContainerMockRecorder struct {
	mock *MockDaggerContainer
}

// NewMockDaggerContainer creates a new mock instance.
func NewMockDaggerContainer(ctrl *gomock.Controller) *MockDaggerContainer {
	mock := &MockDaggerContainer{ctrl: ctrl}
	mock.recorder = &MockDaggerContainerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDaggerContainer) EXPECT() *MockDaggerContainerMockRecorder {
	return m.recorder
}

// File mocks base method.
func (m *MockDaggerContainer) File(arg0 string) pipelines.DaggerFile {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "File", arg0)
	ret0, _ := ret[0].(pipelines.DaggerFile)
	return ret0
}

// File indicates an expected call of File.
func (mr *MockDaggerContainerMockRecorder) File(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "File", reflect.TypeOf((*MockDaggerContainer)(nil).File), arg0)
}

// From mocks base method.
func (m *MockDaggerContainer) From(arg0 string) pipelines.DaggerContainer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "From", arg0)
	ret0, _ := ret[0].(pipelines.DaggerContainer)
	return ret0
}

// From indicates an expected call of From.
func (mr *MockDaggerContainerMockRecorder) From(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "From", reflect.TypeOf((*MockDaggerContainer)(nil).From), arg0)
}

// WithEnvVariable mocks base method.
func (m *MockDaggerContainer) WithEnvVariable(arg0, arg1 string) pipelines.DaggerContainer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithEnvVariable", arg0, arg1)
	ret0, _ := ret[0].(pipelines.DaggerContainer)
	return ret0
}

// WithEnvVariable indicates an expected call of WithEnvVariable.
func (mr *MockDaggerContainerMockRecorder) WithEnvVariable(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithEnvVariable", reflect.TypeOf((*MockDaggerContainer)(nil).WithEnvVariable), arg0, arg1)
}

// WithExec mocks base method.
func (m *MockDaggerContainer) WithExec(arg0 []string, arg1 pipelines.DaggerContainerWithExecOpts) pipelines.DaggerContainer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithExec", arg0, arg1)
	ret0, _ := ret[0].(pipelines.DaggerContainer)
	return ret0
}

// WithExec indicates an expected call of WithExec.
func (mr *MockDaggerContainerMockRecorder) WithExec(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithExec", reflect.TypeOf((*MockDaggerContainer)(nil).WithExec), arg0, arg1)
}

// WithMountedCache mocks base method.
func (m *MockDaggerContainer) WithMountedCache(arg0 string, arg1 pipelines.DaggerCacheVolume) pipelines.DaggerContainer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithMountedCache", arg0, arg1)
	ret0, _ := ret[0].(pipelines.DaggerContainer)
	return ret0
}

// WithMountedCache indicates an expected call of WithMountedCache.
func (mr *MockDaggerContainerMockRecorder) WithMountedCache(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithMountedCache", reflect.TypeOf((*MockDaggerContainer)(nil).WithMountedCache), arg0, arg1)
}

// WithMountedDirectory mocks base method.
func (m *MockDaggerContainer) WithMountedDirectory(arg0 string, arg1 pipelines.DaggerDirectory) pipelines.DaggerContainer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithMountedDirectory", arg0, arg1)
	ret0, _ := ret[0].(pipelines.DaggerContainer)
	return ret0
}

// WithMountedDirectory indicates an expected call of WithMountedDirectory.
func (mr *MockDaggerContainerMockRecorder) WithMountedDirectory(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithMountedDirectory", reflect.TypeOf((*MockDaggerContainer)(nil).WithMountedDirectory), arg0, arg1)
}

// WithWorkdir mocks base method.
func (m *MockDaggerContainer) WithWorkdir(arg0 string) pipelines.DaggerContainer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithWorkdir", arg0)
	ret0, _ := ret[0].(pipelines.DaggerContainer)
	return ret0
}

// WithWorkdir indicates an expected call of WithWorkdir.
func (mr *MockDaggerContainerMockRecorder) WithWorkdir(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithWorkdir", reflect.TypeOf((*MockDaggerContainer)(nil).WithWorkdir), arg0)
}

// MockDaggerCacheVolume is a mock of DaggerCacheVolume interface.
type MockDaggerCacheVolume struct {
	ctrl     *gomock.Controller
	recorder *MockDaggerCacheVolumeMockRecorder
	isgomock struct{}
}

// MockDaggerCacheVolumeMockRecorder is the mock recorder for MockDaggerCacheVolume.
type MockDaggerCacheVolumeMockRecorder struct {
	mock *MockDaggerCacheVolume
}

// NewMockDaggerCacheVolume creates a new mock instance.
func NewMockDaggerCacheVolume(ctrl *gomock.Controller) *MockDaggerCacheVolume {
	mock := &MockDaggerCacheVolume{ctrl: ctrl}
	mock.recorder = &MockDaggerCacheVolumeMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDaggerCacheVolume) EXPECT() *MockDaggerCacheVolumeMockRecorder {
	return m.recorder
}

// MockDaggerFile is a mock of DaggerFile interface.
type MockDaggerFile struct {
	ctrl     *gomock.Controller
	recorder *MockDaggerFileMockRecorder
	isgomock struct{}
}

// MockDaggerFileMockRecorder is the mock recorder for MockDaggerFile.
type MockDaggerFileMockRecorder struct {
	mock *MockDaggerFile
}

// NewMockDaggerFile creates a new mock instance.
func NewMockDaggerFile(ctrl *gomock.Controller) *MockDaggerFile {
	mock := &MockDaggerFile{ctrl: ctrl}
	mock.recorder = &MockDaggerFileMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDaggerFile) EXPECT() *MockDaggerFileMockRecorder {
	return m.recorder
}

// Contents mocks base method.
func (m *MockDaggerFile) Contents(arg0 context.Context) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Contents", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Contents indicates an expected call of Contents.
func (mr *MockDaggerFileMockRecorder) Contents(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Contents", reflect.TypeOf((*MockDaggerFile)(nil).Contents), arg0)
}
